<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Your Magical Notebook</title>
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Caveat:wght@600&family=Kalam:wght@400;700&display=swap"
      rel="stylesheet"
    /> -->

    <style>
      @font-face {
        font-family: "Kalam";
        src: url('{{ url_for("static", filename="fonts/Kalam-Regular.woff2") }}')
          format("woff2");
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }
      @font-face {
        font-family: "Kalam";
        src: url('{{ url_for("static", filename="fonts/Kalam-Bold.woff2") }}')
          format("woff2");
        font-weight: 700;
        font-style: normal;
        font-display: swap;
      }
      @font-face {
        font-family: "Caveat";
        src: url('{{ url_for("static", filename="fonts/Caveat-Bold.woff2") }}')
          format("woff2");
        font-weight: 700;
        font-style: normal;
        font-display: swap;
      }
      :root {
        --parchment: #efe2bf;
        --parchment-deep: #e6d5a6;
        --ink: #2b2622;
        --sepia: #5a3f25;
        --border: #b99b64;
        --gold: #a77b2b;
        --shadow: rgba(0, 0, 0, 0.22);
        --shadow2: rgba(0, 0, 0, 0.1);
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        color: var(--ink);
        font-family: "Kalam", "Caveat", "Inter", system-ui, -apple-system,
          Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        /* Deep parchment stack: creases + grain + burn edges */
        background: radial-gradient(
            ellipse at center,
            rgba(0, 0, 0, 0.1) 0%,
            rgba(0, 0, 0, 0.2) 65%,
            rgba(0, 0, 0, 0.35) 100%
          ),
          /* url("https://i.imgur.com/o7r6n0E.jpg") center/cover fixed, */
            /* burnt edges vignette */
            /* url("https://i.imgur.com/0H0bq3W.png") */ repeat fixed,
          /* heavy paper grain */ /* url("https://i.imgur.com/3n1m3Vw.png") */
            center/cover fixed,
          /* crease/wrinkle overlay */
            linear-gradient(var(--parchment), var(--parchment-deep));
        background-blend-mode: multiply, multiply, overlay, multiply, normal;
      }

      .page-wrap {
        max-width: 1060px;
        margin: 0 auto;
        padding: 22px 16px 40px;
      }
      h1 {
        text-align: center;
        margin: 6px 0 14px;
        color: var(--sepia);
        letter-spacing: 0.5px;
        font-weight: 700;
        text-shadow: 0 1px 0 rgba(255, 255, 255, 0.35);
      }

      .notebook {
        position: relative;
        overflow: hidden;
        border-radius: 18px;
        background: rgba(255, 252, 243, 0.88);
        border: 2px solid var(--border);
        box-shadow: 0 22px 60px var(--shadow), 0 4px 12px var(--shadow2);
      }
      /* Deckled edges and bleed */
      .notebook::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        /* background: url("https://i.imgur.com/Q6cZ7Db.png") repeat; fine grain */
        mix-blend-mode: multiply;
        opacity: 0.3;
      }
      .notebook::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: 
        /* url("https://i.imgur.com/Fr6YxKQ.png") center/cover, */
          /* torn edges/ink bleed */ radial-gradient(
          ellipse at center,
          rgba(0, 0, 0, 0) 65%,
          rgba(0, 0, 0, 0.18) 100%
        );
        mix-blend-mode: multiply;
        opacity: 0.45;
      }

      .ornate-frame {
        position: relative;
        margin: 12px;
        border: 1px solid rgba(90, 63, 37, 0.45);
        border-radius: 16px;
      }
      .ornate-frame::before {
        content: "";
        position: absolute;
        inset: 0;
        border: 12px solid rgba(167, 123, 43, 0.15);
        border-radius: 16px;
        pointer-events: none;
        box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.08);
      }

      .notebook-header {
        padding: 10px 14px;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.92),
            rgba(255, 255, 255, 0.78)
          ),
          repeating-linear-gradient(
            90deg,
            transparent,
            transparent 24px,
            rgba(0, 0, 0, 0.05) 25px,
            transparent 26px
          );
      }
      .ribbon {
        height: 24px;
        min-width: 140px;
        background: linear-gradient(180deg, #d0b06c, #9d7934);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        border-top-right-radius: 6px;
        border-bottom-right-radius: 6px;
        box-shadow: 0 2px 6px var(--shadow2);
        font-weight: 700;
        letter-spacing: 0.5px;
      }
      .progress-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .progress-container {
        flex: 1;
        background: #e3d2a5;
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
      }
      .progress-bar {
        height: 16px;
        width: 0%;
        background: linear-gradient(90deg, #b98b3b, #7fb16e);
        color: #fff;
        font-size: 11px;
        line-height: 16px;
        text-align: right;
        padding-right: 6px;
        transition: width 0.5s ease;
      }

      .header-controls {
        display: flex;
        gap: 8px;
      }
      .btn {
        padding: 7px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fff6e3;
        cursor: pointer;
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);
        transition: transform 0.05s ease, box-shadow 0.2s ease,
          background 0.2s ease;
        font-family: "Kalam", cursive;
        color: var(--sepia);
      }
      .btn:hover {
        background: #fff0cf;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn-gold {
        border-color: var(--gold);
      }
      .btn-ghost {
        background: rgba(255, 255, 255, 0.75);
      }

      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        padding: 8px 14px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.85),
          rgba(255, 255, 255, 0.7)
        );
        border-bottom: 1px dashed var(--border);
      }

      .content {
        display: grid;
        grid-template-rows: auto 1fr auto auto;
      }
      .chat-container {
        padding: 16px;
        height: 56vh;
        overflow-y: auto;
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.64),
            rgba(255, 255, 255, 0.54)
          ),
          repeating-linear-gradient(
            #fffaf0,
            #fffaf0 28px,
            rgba(0, 0, 0, 0.06) 29px,
            #fffaf0 30px
          );
      }

      .note,
      .question {
        position: relative;
        padding: 12px 14px;
        margin: 10px 0;
        border-radius: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        font-size: 1.06rem;
        color: var(--ink);
        border: 1px solid rgba(185, 155, 100, 0.35);
      }
      .note {
        background: rgba(255, 255, 255, 0.92);
        border-left: 6px solid #7fb16e;
      }
      .question {
        background: #fff3d3;
        border-left: 6px solid #b98b3b;
      }

      .typewriter {
        display: inline-block;
        white-space: pre-wrap;
      }
      .input-area {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        padding: 12px 14px;
        border-top: 1px dashed var(--border);
        background: rgba(255, 250, 240, 0.88);
      }
      input[type="text"] {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fffdf6;
        font-family: "Kalam", "Caveat", cursive;
        font-size: 1.05rem;
        color: var(--ink);
      }
      .math-keypad {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
        margin-top: 6px;
      }
      .math-keypad button {
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #fff;
        cursor: pointer;
        font-family: "Kalam", cursive;
      }
      .mic-btn {
        padding: 6px 12px;
        border-radius: 20px;
        border: 1px solid var(--border);
        background: #fff;
        cursor: pointer;
        margin-left: 6px;
      }
      .mic-btn.active {
        background: #ffe9e9;
        border-color: #e57575;
      }

      .persistent-buttons-area {
        display: flex;
        gap: 10px;
        padding: 12px 16px;
        border-top: 1px solid var(--border);
        justify-content: center;
        background: rgba(255, 250, 240, 0.86);
      }
      .raw-json-output {
        background: #fff7ea;
        padding: 10px;
        border-top: 1px dashed var(--border);
        white-space: pre-wrap;
        font-family: ui-monospace, Menlo, Consolas, monospace;
        max-height: 150px;
        overflow: auto;
        color: #5a554d;
      }

      .user-message {
        text-align: right;
        background: #e9fff0;
        padding: 6px 8px;
        margin: 8px 0;
        border-right: 3px solid #7fb16e;
        border-radius: 6px;
      }
      .error-message {
        color: #8b1e1e;
        font-weight: 700;
        background: #ffe8e8;
        padding: 6px;
        border-left: 3px solid #b3261e;
        border-radius: 6px;
        margin: 8px 0;
      }

      /* Drag & drop helpers */
      .rearrange-container {
        border: 1px dashed var(--border);
        padding: 10px;
        min-height: 60px;
        background: #fff;
        border-radius: 10px;
      }
      .rearrange-item {
        background: #f7f3ea;
        padding: 8px;
        border: 1px solid #ccb388;
        border-radius: 8px;
        cursor: grab;
        user-select: none;
        margin-bottom: 6px;
      }
      .rearrange-item.dragging {
        opacity: 0.55;
      }
      .drop-highlight {
        outline: 2px dashed #b98b3b;
        outline-offset: 6px;
        transition: outline-color 0.2s ease;
      }

      /* Spellbook test panel */
      .spellbook {
        padding: 8px 14px;
        border-top: 1px dashed var(--border);
        background: rgba(255, 252, 240, 0.8);
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .spellbook .btn {
        font-size: 0.9rem;
      }
    </style>
    <script src="{{ url_for('static', filename='js/marked.min.js') }}"></script>
  </head>
  <body>
    <div class="page-wrap">
      <h1>Your Magical Notebook âœ¨</h1>
      <div class="notebook">
        <div class="ornate-frame">
          <div class="notebook-header">
            <div class="ribbon">Lesson</div>
            <div class="progress-wrap">
              <div class="progress-container">
                <div class="progress-bar" id="lessonProgressBar">0%</div>
              </div>
            </div>
            <div class="header-controls">
              <button id="toggleTypewriterBtn" class="btn btn-gold">
                Disable Typewriter
              </button>
              <button id="speakSelectionBtn" class="btn btn-ghost">
                ðŸ”Š Speak Selection
              </button>
            </div>
          </div>

          <div class="toolbar">
            <span style="font-weight: 700; color: var(--sepia)">Tools:</span>
            <button id="btnFeedback" class="btn">Give Feedback</button>
            <button id="btnNextLesson" class="btn">Next Lesson</button>
            <button id="btnSkipPractice" class="btn">Skip Practice</button>
            <button id="btnRevealStatus" class="btn">Reveal My Status</button>
          </div>

          <div class="content">
            <div class="chat-container" id="chatContainer"></div>
            <div id="dynamicInputArea" class="input-area"></div>
            <div class="spellbook" id="spellbook">
              <span style="font-weight: 700; color: var(--sepia)"
                >Spellbook (UI test):</span
              >
              <button class="btn" data-spell="notes">Notes</button>
              <button class="btn" data-spell="short">Short Answer</button>
              <button class="btn" data-spell="short-math">
                Short Answer (Math)
              </button>
              <button class="btn" data-spell="mcq">MCQ</button>
              <button class="btn" data-spell="checkbox">Checkbox</button>
              <button class="btn" data-spell="slider">Slider</button>
              <button class="btn" data-spell="rearrange">Rearrange</button>
              <button class="btn" data-spell="draw">Drawing</button>
            </div>
            <div
              id="persistentButtonsArea"
              class="persistent-buttons-area"
            ></div>
            <div class="raw-json-output">
              <strong>Raw LLM Response (debug):</strong>
              <pre id="rawOutput"></pre>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const sessionId = "{{ session_id }}";
      const chatContainer = document.getElementById("chatContainer");
      const dynamicInputArea = document.getElementById("dynamicInputArea");
      const rawOutputDiv = document.getElementById("rawOutput");
      const lessonProgressBar = document.getElementById("lessonProgressBar");
      const toggleTypewriterBtn = document.getElementById(
        "toggleTypewriterBtn"
      );
      const speakSelectionBtn = document.getElementById("speakSelectionBtn");
      const spellbook = document.getElementById("spellbook");

      const btnFeedback = document.getElementById("btnFeedback");
      const btnNextLesson = document.getElementById("btnNextLesson");
      const btnSkipPractice = document.getElementById("btnSkipPractice");
      const btnRevealStatus = document.getElementById("btnRevealStatus");

      // Fix 1: Pending input meta to route answers correctly (no accidental handle_user_question)
      let pendingInputMeta = null; // { type: 'paraphrase'|'summary'|'answer'|'feedback', variable: '...' }

      // Typewriter toggle
      let typewriterEnabled =
        (localStorage.getItem("typewriterEnabled") ?? "true") === "true";
      const updateTypewriterButton = () =>
        (toggleTypewriterBtn.textContent = typewriterEnabled
          ? "Disable Typewriter"
          : "Enable Typewriter");
      toggleTypewriterBtn.addEventListener("click", () => {
        typewriterEnabled = !typewriterEnabled;
        localStorage.setItem("typewriterEnabled", String(typewriterEnabled));
        updateTypewriterButton();
      });
      updateTypewriterButton();

      // Speak selection
      function speak(text) {
        if (!window.speechSynthesis) {
          alert("Speech not supported.");
          return;
        }
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "en-US";
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      }
      const getSelectionText = () =>
        (window.getSelection()?.toString() || "").trim();
      speakSelectionBtn.addEventListener("click", () => {
        const t = getSelectionText();
        if (t) speak(t);
      });
      chatContainer.addEventListener("dblclick", () => {
        const t = getSelectionText();
        if (t) speak(t);
      });

      // Status
      let currentStatus = {
        learning_confidence: 5,
        learning_interest: 5,
        learning_patience: 5,
        effort_focus: 10,
        weak_concept_spot: {},
        current_lesson_progress: 0,
        lesson_stage: "not_in_lesson",
        current_lesson_title: "",
        active_question_id: "",
      };

      function updateProgressBar(p) {
        p = Math.max(0, Math.min(100, p || 0));
        lessonProgressBar.style.width = `${p}%`;
        lessonProgressBar.textContent = `${Math.round(p)}%`;
      }
      function updateToolbarButtons() {
        const stage = currentStatus.lesson_stage,
          progress = currentStatus.current_lesson_progress;
        btnNextLesson.disabled = !(
          stage === "lesson_complete" || progress >= 95
        );
        btnNextLesson.style.opacity = btnNextLesson.disabled ? 0.5 : 1;
        btnSkipPractice.style.display =
          stage === "practice" ? "inline-block" : "none";
      }

      // Toolbar actions
      btnFeedback.addEventListener("click", () =>
        sendActionToBackend("give_feedback", {})
      );
      btnNextLesson.addEventListener("click", () =>
        sendActionToBackend("start_lesson", { lesson_index: "next" })
      );
      btnSkipPractice.addEventListener("click", () =>
        sendActionToBackend("skip_practice", {})
      );
      btnRevealStatus.addEventListener("click", renderStatusSnapshot);

      function renderStatusSnapshot() {
        const s = currentStatus;
        const html = `
          <div><strong>Confidence:</strong> ${s.learning_confidence}/10</div>
          <div><strong>Interest:</strong> ${s.learning_interest}/10</div>
          <div><strong>Patience:</strong> ${s.learning_patience}/10</div>
          <div><strong>Focus:</strong> ${s.effort_focus}/10</div>
          <div><strong>Stage:</strong> ${s.lesson_stage}</div>
          <div><strong>Progress:</strong> ${s.current_lesson_progress}%</div>`;
        const el = document.createElement("div");
        el.className = "note";
        el.innerHTML = html;
        chatContainer.appendChild(el);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      async function sendActionToBackend(command, parameters = {}) {
        const payload = {
          session_id: sessionId,
          user_action: { command, parameters },
        };
        const msg = document.createElement("div");
        msg.className = "user-message";
        msg.innerHTML = `<strong>You:</strong> ${command} ${
          Object.keys(parameters).length ? JSON.stringify(parameters) : ""
        }`;
        chatContainer.appendChild(msg);

        try {
          const res = await fetch("/ask", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          rawOutputDiv.textContent = JSON.stringify(data, null, 2);
          dynamicInputArea.innerHTML = ""; // cleared after each response
          pendingInputMeta = null; // clear meta so we donâ€™t misroute next time

          if (data.current_status) {
            currentStatus = data.current_status;
            updateProgressBar(currentStatus.current_lesson_progress || 0);
            updateToolbarButtons();
          }
          if (Array.isArray(data.actions)) {
            for (const a of data.actions) renderUICommand(a);
          } else {
            const e = document.createElement("div");
            e.className = "error-message";
            e.textContent = "Invalid AI response format.";
            chatContainer.appendChild(e);
          }
        } catch (err) {
          const e = document.createElement("div");
          e.className = "error-message";
          e.textContent = `Error communicating with AI: ${err.message}`;
          chatContainer.appendChild(e);
        } finally {
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }
      }

      // Typewriter helper
      function typewriterInsert(container, html) {
        if (!typewriterEnabled) {
          container.innerHTML = html;
          return;
        }
        const temp = document.createElement("div");
        temp.innerHTML = html;
        const text = temp.textContent || temp.innerText || "";
        const wrapper = document.createElement("div");
        wrapper.className = "typewriter";
        container.appendChild(wrapper);
        let i = 0;
        const speed = 12;
        const interval = setInterval(() => {
          wrapper.textContent = text.slice(0, i++);
          if (i > text.length) clearInterval(interval);
        }, speed);
      }

      // Render UI commands
      function renderUICommand(action) {
        const p = action.parameters || {};
        switch (action.command) {
          case "ui_display_notes": {
            const el = document.createElement("div");
            el.className = "note";
            chatContainer.appendChild(el);
            typewriterInsert(el, marked.parse(p.content || ""));
            break;
          }
          case "ui_short_answer": {
            const q = document.createElement("div");
            q.className = "question";
            chatContainer.appendChild(q);
            typewriterInsert(q, marked.parse(p.question_text || ""));
            const v = p.variable_name;
            // Decide routing meta based on variable naming conventions
            if (v === "initial_paraphrase")
              pendingInputMeta = { type: "paraphrase", variable: v };
            else if (v === "final_summary")
              pendingInputMeta = { type: "summary", variable: v };
            else if (v === "user_feedback_input")
              pendingInputMeta = { type: "feedback", variable: v };
            else pendingInputMeta = { type: "answer", variable: v }; // default: treat as answer

            const needsMath = p.hints && p.hints.math_input === true;
            dynamicInputArea.innerHTML = `
              <input type="text" id="${v}" placeholder="${p.placeholder || ""}">
              <button class="btn btn-gold" onclick="handleUserInput('${v}','text')">Send</button>
              ${
                needsMath
                  ? `
              <div class="math-keypad" aria-label="Math keypad">
                <button data-k="+">+</button><button data-k="-">âˆ’</button><button data-k="*">Ã—</button><button data-k="/">Ã·</button>
                <button data-k="=">=</button><button data-k="^">^</button><button data-k="(">(</button><button data-k=")">)</button>
                <button data-k="x">x</button><button data-k="y">y</button>
                <button data-k="backspace">âŒ«</button><button data-k="clear">Clear</button>
                <button id="micBtn" class="mic-btn">ðŸŽ¤ Press to speak</button>
              </div>`
                  : `
              <button id="micBtn" class="mic-btn">ðŸŽ¤ Press to speak</button>`
              }
            `;
            if (needsMath) attachMathKeypadHandlers(v);
            attachVoiceToInput("micBtn", v);
            document.getElementById(v)?.focus();
            break;
          }
          case "ui_mcq": {
            const el = document.createElement("div");
            el.className = "question";
            chatContainer.appendChild(el);
            typewriterInsert(el, marked.parse(p.question_text || ""));
            const opts = (p.options || [])
              .map(
                (opt, i) =>
                  `<label><input type="radio" name="${p.variable_name}" value="${opt}" id="${p.variable_name}_${i}"> ${opt}</label><br>`
              )
              .join("");
            dynamicInputArea.innerHTML = `<div>${opts}</div><button class="btn btn-gold" onclick="handleUserInput('${p.variable_name}','radio')">Submit</button>`;
            // Route as answer
            pendingInputMeta = { type: "answer", variable: p.variable_name };
            break;
          }
          case "ui_checkbox": {
            const el = document.createElement("div");
            el.className = "question";
            chatContainer.appendChild(el);
            typewriterInsert(el, marked.parse(p.question_text || ""));
            const opts = (p.options || [])
              .map(
                (opt, i) =>
                  `<label><input type="checkbox" name="${p.variable_name}" value="${opt}" id="${p.variable_name}_${i}"> ${opt}</label><br>`
              )
              .join("");
            dynamicInputArea.innerHTML = `<div>${opts}</div><button class="btn btn-gold" onclick="handleUserInput('${p.variable_name}','checkbox')">Submit</button>`;
            pendingInputMeta = { type: "answer", variable: p.variable_name };
            break;
          }
          case "ui_slider": {
            const el = document.createElement("div");
            el.className = "question";
            chatContainer.appendChild(el);
            typewriterInsert(el, marked.parse(p.question_text || ""));
            const def =
              typeof p.min === "number" && typeof p.max === "number"
                ? p.min
                : 1;
            dynamicInputArea.innerHTML = `
              <input type="range" id="${p.variable_name}" min="${p.min}" max="${p.max}" value="${def}">
              <div style="display:flex;justify-content:space-between;"><span>${p.min}</span><span id="${p.variable_name}_value">${def}</span><span>${p.max}</span></div>
              <button class="btn btn-gold" onclick="handleUserInput('${p.variable_name}','slider')">Submit</button>`;
            document
              .getElementById(p.variable_name)
              .addEventListener("input", (e) => {
                document.getElementById(
                  `${p.variable_name}_value`
                ).textContent = e.target.value;
              });
            // sliders are feedback-ish; keep default routing to handle_user_question only if no meta was set elsewhere
            pendingInputMeta = { type: "answer", variable: p.variable_name };
            break;
          }
          case "ui_rearrange_order": {
            const el = document.createElement("div");
            el.className = "question";
            chatContainer.appendChild(el);
            typewriterInsert(el, marked.parse(p.question_text || ""));
            const items = (p.items || [])
              .map(
                (it, i) =>
                  `<div class="rearrange-item" draggable="true" data-value="${it}" id="${p.variable_name}_item_${i}">${it}</div>`
              )
              .join("");
            dynamicInputArea.innerHTML = `
              <div id="${p.variable_name}_container" class="rearrange-container drop-highlight" aria-label="Drag items to reorder">${items}</div>
              <input type="hidden" id="${p.variable_name}_ordered_values" value="[]">
              <button class="btn btn-gold" onclick="
                const items=Array.from(document.querySelectorAll('#${p.variable_name}_container .rearrange-item')).map(i=>i.dataset.value);
                document.getElementById('${p.variable_name}_ordered_values').value=JSON.stringify(items);
                handleUserInput('${p.variable_name}','rearrange_order');">Submit Order</button>`;
            // Improved drag + drop anywhere in container
            const container = document.getElementById(
              `${p.variable_name}_container`
            );
            let dragged = null;
            container.addEventListener("dragstart", (e) => {
              const t = e.target;
              if (!t.classList.contains("rearrange-item")) return;
              dragged = t;
              dragged.classList.add("dragging");
              e.dataTransfer.effectAllowed = "move";
              e.dataTransfer.setData("text/plain", t.dataset.value);
            });
            container.addEventListener("dragover", (e) => {
              e.preventDefault();
              const after = getDragAfterElement(container, e.clientY);
              if (after == null) container.appendChild(dragged);
              else container.insertBefore(dragged, after);
            });
            container.addEventListener("drop", (e) => {
              e.preventDefault();
              dragged && dragged.classList.remove("dragging");
              dragged = null;
            });
            container.addEventListener("dragend", () => {
              dragged && dragged.classList.remove("dragging");
              dragged = null;
            });
            function getDragAfterElement(container, y) {
              const els = [
                ...container.querySelectorAll(".rearrange-item:not(.dragging)"),
              ];
              return els.reduce(
                (closest, child) => {
                  const box = child.getBoundingClientRect();
                  const offset = y - box.top - box.height / 2;
                  if (offset < 0 && offset > closest.offset) {
                    return { offset, element: child };
                  } else {
                    return closest;
                  }
                },
                { offset: Number.NEGATIVE_INFINITY }
              ).element;
            }
            pendingInputMeta = { type: "answer", variable: p.variable_name };
            break;
          }
          case "ui_drawing_board": {
            const el = document.createElement("div");
            el.className = "question";
            chatContainer.appendChild(el);
            typewriterInsert(el, marked.parse(p.prompt_text || ""));
            dynamicInputArea.innerHTML = `
              <canvas id="${p.variable_name}_canvas" width="320" height="180" style="border:1px solid var(--border);background:#fff;border-radius:8px"></canvas>
              <input type="hidden" id="${p.variable_name}_image_data" value="">
              <button class="btn btn-gold" onclick="
                const c=document.getElementById('${p.variable_name}_canvas');
                const d=c.toDataURL('image/png');
                document.getElementById('${p.variable_name}_image_data').value=d;
                handleUserInput('${p.variable_name}','drawing_board');">Submit Drawing</button>`;
            const canvas = document.getElementById(`${p.variable_name}_canvas`);
            const ctx = canvas.getContext("2d");
            let isDrawing = false;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.strokeStyle = "#000";
            const getPos = (e) => {
              const r = canvas.getBoundingClientRect();
              const x = e.touches ? e.touches[0].clientX : e.clientX;
              const y = e.touches ? e.touches[0].clientY : e.clientY;
              return { x: x - r.left, y: y - r.top };
            };
            const start = (e) => {
              e.preventDefault();
              isDrawing = true;
              ctx.beginPath();
              const p2 = getPos(e);
              ctx.moveTo(p2.x, p2.y);
            };
            const move = (e) => {
              if (!isDrawing) return;
              e.preventDefault();
              const p2 = getPos(e);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            };
            const end = () => {
              isDrawing = false;
            };
            canvas.addEventListener("mousedown", start);
            canvas.addEventListener("mousemove", move);
            canvas.addEventListener("mouseup", end);
            canvas.addEventListener("mouseout", end);
            canvas.addEventListener("touchstart", start);
            canvas.addEventListener("touchmove", move);
            canvas.addEventListener("touchend", end);
            canvas.addEventListener("touchcancel", end);
            pendingInputMeta = { type: "answer", variable: p.variable_name };
            break;
          }
          case "ui_button": {
            const b = document.createElement("button");
            b.className = "btn btn-gold";
            b.textContent = p.text || "Continue";
            b.addEventListener("click", () =>
              sendActionToBackend(
                p.next_command,
                p.next_command_parameters || {}
              )
            );
            dynamicInputArea.appendChild(b);
            break;
          }
          default: {
            const e = document.createElement("div");
            e.className = "error-message";
            e.textContent = `Unknown UI Command: ${action.command}`;
            chatContainer.appendChild(e);
          }
        }
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function attachMathKeypadHandlers(inputId) {
        const area = dynamicInputArea.querySelector(".math-keypad");
        if (!area) return;
        const input = document.getElementById(inputId);
        area.addEventListener("click", (e) => {
          const btn = e.target.closest("button");
          if (!btn || !btn.dataset.k) return;
          const k = btn.dataset.k;
          if (k === "clear") input.value = "";
          else if (k === "backspace") input.value = input.value.slice(0, -1);
          else input.value += k === "*" ? "*" : k;
          input.focus();
        });
      }

      // SpeechRecognition
      function attachVoiceToInput(buttonId, inputId) {
        const micBtn = document.getElementById(buttonId);
        if (!micBtn) return;
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) {
          micBtn.disabled = true;
          micBtn.title = "Speech not supported in this browser.";
          return;
        }
        const rec = new SR();
        rec.lang = "en-US";
        rec.interimResults = false;
        rec.maxAlternatives = 1;
        micBtn.addEventListener("click", () => {
          if (micBtn.classList.contains("active")) {
            rec.stop();
            micBtn.classList.remove("active");
          } else {
            rec.start();
            micBtn.classList.add("active");
          }
        });
        rec.addEventListener("result", (e) => {
          const t = e.results[0][0].transcript || "";
          const input = document.getElementById(inputId);
          if (input) input.value = t;
        });
        rec.addEventListener("end", () => micBtn.classList.remove("active"));
        rec.addEventListener("error", () => micBtn.classList.remove("active"));
      }

      function getQueryParam(k) {
        return new URLSearchParams(window.location.search).get(k);
      }

      // Route submission using pendingInputMeta first
      function handleUserInput(variableName, inputType) {
        let value;
        if (inputType === "text") {
          value = document.getElementById(variableName).value;
          if (!value.trim()) {
            alert("Please enter something.");
            return;
          }
        } else if (inputType === "radio") {
          const sel = document.querySelector(
            `input[name="${variableName}"]:checked`
          );
          if (!sel) {
            alert("Please select an option.");
            return;
          }
          value = sel.value;
        } else if (inputType === "checkbox") {
          const sel = document.querySelectorAll(
            `input[name="${variableName}"]:checked`
          );
          if (!sel.length) {
            alert("Please select at least one option.");
            return;
          }
          value = Array.from(sel).map((cb) => cb.value);
        } else if (inputType === "slider") {
          value = document.getElementById(variableName).value;
        } else if (inputType === "rearrange_order") {
          const hid = document.getElementById(`${variableName}_ordered_values`);
          if (!hid || !hid.value || hid.value === "[]") {
            alert("Please arrange the items.");
            return;
          }
          try {
            value = JSON.parse(hid.value);
          } catch {
            alert("Could not process rearrangement.");
            return;
          }
        } else if (inputType === "drawing_board") {
          const hid = document.getElementById(`${variableName}_image_data`);
          if (!hid || !hid.value.trim()) {
            alert("Please draw something.");
            return;
          }
          value = hid.value;
        }

        let nextCommand,
          nextParams = {};

        // Priority routing using pendingInputMeta to avoid misclassification
        if (pendingInputMeta && pendingInputMeta.variable === variableName) {
          if (pendingInputMeta.type === "paraphrase") {
            nextCommand = "evaluate_paraphrase";
            nextParams.user_input = value;
          } else if (pendingInputMeta.type === "summary") {
            nextCommand = "evaluate_summary";
            nextParams.user_input = value;
          } else if (pendingInputMeta.type === "feedback") {
            nextCommand = "process_feedback";
            nextParams.feedback = value;
          } else {
            // "answer"
            nextCommand = "evaluate_answer";
            nextParams.user_answer = value;
            nextParams.question_id = variableName;
          }
        } else {
          // Fallback heuristics
          if (variableName === "topic_query") {
            nextCommand = "generate_course_plan";
            nextParams.query = value;
          } else if (variableName === "initial_paraphrase") {
            nextCommand = "evaluate_paraphrase";
            nextParams.user_input = value;
          } else if (variableName === "final_summary") {
            nextCommand = "evaluate_summary";
            nextParams.user_input = value;
          } else if (
            variableName.startsWith("q_lesson") ||
            variableName.startsWith("q_checkpoint_")
          ) {
            nextCommand = "evaluate_answer";
            nextParams.user_answer = value;
            nextParams.question_id = variableName;
          } else if (variableName === "user_feedback_input") {
            nextCommand = "process_feedback";
            nextParams.feedback = value;
          } else {
            nextCommand = "handle_user_question";
            nextParams.user_question_value = value;
            nextParams.input_variable_name = variableName;
            nextParams.input_type = inputType;
          }
        }

        sendActionToBackend(nextCommand, nextParams);
      }

      // Spellbook: local UI test without LLM
      spellbook.addEventListener("click", (e) => {
        const b = e.target.closest("button[data-spell]");
        if (!b) return;
        const s = b.dataset.spell;
        const fake = (cmd, params) =>
          renderUICommand({ command: cmd, parameters: params || {} });
        if (s === "notes")
          fake("ui_display_notes", {
            content:
              "### Ancient Note\nThis is a parchment-style note with ink bleed and creases.",
          });
        if (s === "short")
          fake("ui_short_answer", {
            question_text: "Write a sentence about gravity.",
            variable_name: "test_short",
            placeholder: "Your thought...",
          });
        if (s === "short-math")
          fake("ui_short_answer", {
            question_text:
              "Compute 3x + 2 = 11. Solve for x. Use the math keypad.",
            variable_name: "test_short_math",
            placeholder: "x = ...",
            hints: { math_input: true },
          });
        if (s === "mcq")
          fake("ui_mcq", {
            question_text: "Which is prime?",
            options: ["12", "15", "17"],
            variable_name: "test_mcq",
          });
        if (s === "checkbox")
          fake("ui_checkbox", {
            question_text: "Select all even numbers:",
            options: ["2", "3", "6", "9"],
            variable_name: "test_cbx",
          });
        if (s === "slider")
          fake("ui_slider", {
            question_text: "How confident are you? (demo)",
            min: 1,
            max: 10,
            variable_name: "test_slider",
          });
        if (s === "rearrange")
          fake("ui_rearrange_order", {
            question_text: "Put in ascending order:",
            items: ["7", "2", "9", "4"],
            variable_name: "test_reorder",
          });
        if (s === "draw")
          fake("ui_drawing_board", {
            prompt_text: "Sketch a right triangle.",
            variable_name: "test_drawing",
          });
      });

      // Init
      window.onload = () => {
        const userName =
          prompt("Welcome! What's your name, learner?") || "Learner";

        const topic = getQueryParam("topic") || "";
        const subtopic = getQueryParam("subtopic") || "";
        sendActionToBackend("init", {
          user_name: userName,
          generate_course_plan: subtopic + "start planing",
        });
        // sendActionToBackend("generate_course_plan", {
        //   query: [topic, subtopic].filter(Boolean).join(": "),
        // });
        updateProgressBar(currentStatus.current_lesson_progress);
        updateToolbarButtons();
      };
    </script>
  </body>
</html>
