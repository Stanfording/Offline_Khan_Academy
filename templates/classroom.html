<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Magic Notebook</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
        display: flex;
        flex-direction: column;
        height: calc(100vh - 40px); /* Adjust for margin */
      }
      h1 {
        text-align: center;
        color: #333;
      }
      .progress-container {
        width: 100%;
        background-color: #f0f0f0;
        border-radius: 5px;
        margin-bottom: 10px;
        overflow: hidden;
      }
      .progress-bar {
        height: 20px;
        width: 0%;
        background-color: #4caf50;
        text-align: center;
        color: white;
        line-height: 20px;
        border-radius: 5px;
        transition: width 0.5s ease-in-out;
      }
      .chat-container {
        border: 1px solid #ccc;
        padding: 10px;
        flex-grow: 1; /* Allows it to take up available space */
        overflow-y: scroll;
        margin-bottom: 10px;
        background-color: #f9f9f9;
        display: flex;
        flex-direction: column; /* Stack messages */
      }
      .input-area {
        display: flex;
        gap: 5px;
        flex-wrap: wrap; /* Allow elements to wrap */
        margin-bottom: 10px; /* Space above persistent buttons */
      }
      .persistent-buttons-area {
        display: flex;
        gap: 10px;
        padding: 10px 0;
        border-top: 1px solid #eee;
        justify-content: center;
      }
      .raw-json-output {
        background-color: #eee;
        padding: 10px;
        border: 1px dashed #999;
        white-space: pre-wrap;
        font-family: monospace;
        margin-top: 10px;
        flex-shrink: 0; /* Don't let it shrink */
        overflow: auto; /* Allow scrolling if content is too large */
        max-height: 150px; /* Limit height */
      }
      .note {
        background-color: #e0f7fa;
        padding: 10px;
        margin-bottom: 5px;
        border-left: 5px solid #00bcd4;
      }
      .question {
        background-color: #fffde7;
        padding: 10px;
        margin-bottom: 5px;
        border-left: 5px solid #ffeb3b;
      }
      .user-message {
          text-align: right;
          background-color: #e7ffe7;
          padding: 5px;
          margin: 5px 0;
          border-right: 3px solid #00c853;
      }
      .error-message {
          color: red;
          font-weight: bold;
          background-color: #ffe0e0;
          padding: 5px;
          margin: 5px 0;
          border-left: 3px solid red;
      }
      button {
        padding: 8px 15px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        border-radius: 4px;
      }
      button:hover {
        background-color: #e0e0e0;
      }
      input[type="text"] {
        flex-grow: 1;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      /* Styles for new UI types */
      .rearrange-container {
        border: 1px dashed #ccc;
        padding: 10px;
        min-height: 50px;
        background-color: #fff;
        display: flex;
        flex-direction: column; /* Items stack vertically */
        gap: 5px;
        width: 100%; /* Take full width */
      }
      .rearrange-item {
        background-color: #e6e6fa;
        padding: 8px;
        border: 1px solid #c3c3e6;
        cursor: grab;
        user-select: none;
      }
      .rearrange-item.dragging {
        opacity: 0.5;
      }
      canvas {
        touch-action: none; /* Prevent scrolling on touch devices */
        background-color: #fff;
        border: 1px solid #000;
        max-width: 100%; /* Responsive canvas */
        height: auto;
      }
      input[type="range"] {
          width: 100%;
          margin: 10px 0;
      }
      input[type="radio"], input[type="checkbox"] {
          margin-right: 5px;
      }
      label {
          margin-bottom: 5px;
      }
    </style>
    <!-- IMPORTANT: Add the marked.js CDN script here, or just before your custom script -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <h1>The Magic Notebook âœ¨</h1>

    <div class="progress-container">
        <div class="progress-bar" id="lessonProgressBar">0%</div>
    </div>

    <div class="chat-container" id="chatContainer">
      <!-- Messages and UI will be rendered here -->
    </div>

    <div id="dynamicInputArea" class="input-area">
      <!-- Dynamic input elements will appear here -->
    </div>

    <div id="persistentButtonsArea" class="persistent-buttons-area">
        <!-- Persistent buttons will be rendered here by JS -->
    </div>

    <div class="raw-json-output">
      <h3>Raw LLM Response (for debug):</h3>
      <pre id="rawOutput"></pre>
    </div>

    <!-- Your custom JavaScript code MUST be within <script> tags like this -->
    <script>
      const sessionId = "{{ session_id }}";
      const chatContainer = document.getElementById("chatContainer");
      const dynamicInputArea = document.getElementById("dynamicInputArea");
      const rawOutputDiv = document.getElementById("rawOutput");
      const lessonProgressBar = document.getElementById("lessonProgressBar");
      const persistentButtonsArea = document.getElementById("persistentButtonsArea");

      // Global state variables for frontend UI - will be synced with backend
      let currentStatus = {
          learning_confidence: 5,
          learning_interest: 5,
          learning_patience: 5,
          effort_focus: 10,
          weak_concept_spot: {},
          current_lesson_progress: 0,
          current_lesson_stage: "initial",
          current_lesson_title: "",
          active_question_id: ""
      }; // Initial state, will be overwritten by first backend response

      // Function to update the progress bar's visual state
      function updateProgressBar(progress) {
        progress = Math.max(0, Math.min(100, progress)); // Clamp between 0 and 100
        lessonProgressBar.style.width = `${progress}%`;
        lessonProgressBar.textContent = `${Math.round(progress)}%`;
      }

      // Function to setup (create) persistent buttons. Called once on page load.
      function setupPersistentButtons() {
          persistentButtonsArea.innerHTML = `
              <button id="btnFeedback">Give Feedback</button>
              <button id="btnNextLesson">Next Lesson</button>
              <button id="btnSkipPractice">Skip Practice</button>
              <button id="btnRevealStatus">Reveal My Status</button>
          `;

          // Attach event listeners to persistent buttons
          document.getElementById('btnFeedback').addEventListener('click', () => {
              sendActionToBackend('give_feedback', {});
          });
          document.getElementById('btnNextLesson').addEventListener('click', () => {
              sendActionToBackend('next_lesson', {});
          });
          document.getElementById('btnSkipPractice').addEventListener('click', () => {
              sendActionToBackend('skip_practice', {});
          });
          document.getElementById('btnRevealStatus').addEventListener('click', () => {
              sendActionToBackend('reveal_status', {});
          });

          // Call updatePersistentButtons to set initial state (e.g., enable/disable)
          updatePersistentButtons();
      }

      // Function to update (enable/disable/hide) persistent buttons based on current state
      function updatePersistentButtons() {
          const stage = currentStatus.current_lesson_stage;
          const progress = currentStatus.current_lesson_progress;

          const btnFeedback = document.getElementById('btnFeedback');
          const btnNextLesson = document.getElementById('btnNextLesson');
          const btnSkipPractice = document.getElementById('btnSkipPractice');
          const btnRevealStatus = document.getElementById('btnRevealStatus');

          if (btnFeedback) btnFeedback.disabled = false; // Always enabled
          if (btnRevealStatus) btnRevealStatus.disabled = false; // Always enabled

          // Next Lesson button: Enabled if lesson is mostly complete or if stage is 'lesson_complete'
          if (btnNextLesson) {
              btnNextLesson.disabled = !(stage === 'lesson_complete' || progress >= 95);
              // Only show after course plan is generated
              btnNextLesson.style.display = (stage && stage !== 'initial' && stage !== 'topic_selection') ? 'inline-block' : 'none';
          }
          // Skip Practice button: Only enabled/visible during 'practice' or 'summary_check' stage
          if (btnSkipPractice) {
              btnSkipPractice.style.display = (stage === 'practice' || stage === 'summary_check') ? 'inline-block' : 'none';
          }
      }

      async function sendActionToBackend(command, parameters = {}) {
        const payload = {
          session_id: sessionId,
          user_action: {
            command: command,
            parameters: parameters,
          },
        };

        chatContainer.innerHTML += `<div class="user-message"><strong>You:</strong> Command '${command}' with params ${JSON.stringify(
          parameters
        )}</div>`;

        try {
          const response = await fetch("/ask", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          rawOutputDiv.textContent = JSON.stringify(data, null, 2); // Display raw JSON for debug

          // Clear previous dynamic input area AFTER response is received
          dynamicInputArea.innerHTML = ""; 

          // --- IMPORTANT: Update currentStatus with the latest from the backend ---
          if (data.current_status) {
              currentStatus = data.current_status;
              updateProgressBar(currentStatus.current_lesson_progress || 0);
              updatePersistentButtons();
          }

          // Process and render UI commands
          if (data.actions && Array.isArray(data.actions)) {
            for (const action of data.actions) {
              renderUICommand(action);
            }
          } else {
            chatContainer.innerHTML += `<div class="error-message">Error: Invalid response format from AI.</div>`;
          }
        } catch (error) {
          console.error("Error sending action to backend:", error);
          chatContainer.innerHTML += `<div class="error-message">Error communicating with AI: ${error.message}</div>`;
        } finally {
          chatContainer.scrollTop = chatContainer.scrollHeight; // Scroll to bottom
        }
      }

      function renderUICommand(action) {
        const params = action.parameters;
        switch (action.command) {
          case "ui_display_notes":
            // Marked.parse will display LLM's Jinja-like templating for status_dictionary literally.
            // For a production app, you might preprocess params.content on the backend or frontend
            // to substitute actual values from `currentStatus` before calling marked.parse.
            chatContainer.innerHTML += `<div class="note">${marked.parse(
              params.content
            )}</div>`;
            break;
          case "ui_short_answer":
            chatContainer.innerHTML += `<div class="question">${marked.parse(
              params.question_text
            )}</div>`;
            dynamicInputArea.innerHTML = `
                        <input type="text" id="${
                          params.variable_name
                        }" placeholder="${params.placeholder || ""}">
                        <button onclick="handleUserInput('${
                          params.variable_name
                        }', 'text')">Send</button>
                    `;
            document.getElementById(params.variable_name).focus();
            break;
          case "ui_mcq":
            chatContainer.innerHTML += `<div class="question">${marked.parse(
              params.question_text
            )}</div>`;
            let optionsHtml = params.options
              .map(
                (opt, index) => `
                        <label><input type="radio" name="${params.variable_name}" value="${opt}" id="${params.variable_name}_${index}"> ${opt}</label><br>
                    `
              )
              .join("");
            dynamicInputArea.innerHTML = `
                        <div>${optionsHtml}</div>
                        <button onclick="handleUserInput('${params.variable_name}', 'radio')">Submit</button>
                    `;
            break;
          case "ui_button":
            const button = document.createElement('button');
            button.textContent = params.text;
            button.addEventListener('click', () => {
              sendActionToBackend(params.next_command, params.next_command_parameters || {});
            });
            dynamicInputArea.appendChild(button);
            break;
          case "ui_checkbox": 
            chatContainer.innerHTML += `<div class="question">${marked.parse(
              params.question_text
            )}</div>`;
            let checkboxOptionsHtml = params.options
              .map(
                (opt, index) => `
                        <label><input type="checkbox" name="${params.variable_name}" value="${opt}" id="${params.variable_name}_${index}"> ${opt}</label><br>
                    `
              )
              .join("");
            dynamicInputArea.innerHTML = `
                        <div>${checkboxOptionsHtml}</div>
                        <button onclick="handleUserInput('${params.variable_name}', 'checkbox')">Submit</button>
                    `;
            break;
          case "ui_slider":
            chatContainer.innerHTML += `<div class="question">${marked.parse(
              params.question_text
            )}</div>`;
            dynamicInputArea.innerHTML = `
                        <input type="range" id="${params.variable_name}" min="${params.min}" max="${params.max}" value="${params.min || Math.floor((params.min + params.max) / 2)}" style="width: 100%;">
                        <div style="display: flex; justify-content: space-between;">
                            <span>${params.min}</span>
                            <span id="${params.variable_name}_value">${params.min || Math.floor((params.min + params.max) / 2)}</span>
                            <span>${params.max}</span>
                        </div>
                        <button onclick="handleUserInput('${params.variable_name}', 'slider')">Submit</button>
                    `;
            document.getElementById(params.variable_name).addEventListener('input', (event) => {
                document.getElementById(`${params.variable_name}_value`).textContent = event.target.value;
            });
            break;
          case "ui_rearrange_order": 
            chatContainer.innerHTML += `<div class="question">${marked.parse(
              params.question_text
            )}</div>`;
            let rearrangeItemsHtml = params.items
              .map(
                (item, index) =>
                  `<div class="rearrange-item" draggable="true" data-value="${item}" id="${params.variable_name}_item_${index}">${item}</div>`
              )
              .join("");

            dynamicInputArea.innerHTML = `
                        <div id="${params.variable_name}_container" class="rearrange-container">
                            ${rearrangeItemsHtml}
                        </div>
                        <input type="hidden" id="${params.variable_name}_ordered_values" value='[]'>
                        <button onclick="
                            const currentItems = Array.from(document.querySelectorAll('#${params.variable_name}_container .rearrange-item'))
                                .map(item => item.dataset.value);
                            document.getElementById('${params.variable_name}_ordered_values').value = JSON.stringify(currentItems);
                            handleUserInput('${params.variable_name}', 'rearrange_order');
                        ">Submit Order</button>
                    `;
            const container = document.getElementById(`${params.variable_name}_container`);
            let draggedItem = null;
            container.addEventListener('dragstart', (e) => {
                draggedItem = e.target;
                if (draggedItem.classList.contains('rearrange-item')) {
                    setTimeout(() => draggedItem.classList.add('dragging'), 0);
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', draggedItem.dataset.value);
                } else {
                    e.preventDefault();
                }
            });
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                const target = e.target;
                if (target.classList.contains('rearrange-item') && target !== draggedItem) {
                    const bounding = target.getBoundingClientRect();
                    const offset = bounding.y + (bounding.height / 2);
                    if (e.clientY > offset) {
                        container.insertBefore(draggedItem, target.nextSibling);
                    } else {
                        container.insertBefore(draggedItem, target);
                    }
                }
            });
            container.addEventListener('dragend', () => {
                if (draggedItem) {
                    draggedItem.classList.remove('dragging');
                    draggedItem = null;
                }
            });
            break;
          case "ui_drawing_board":
            chatContainer.innerHTML += `<div class="question">${marked.parse(
              params.prompt_text
            )}</div>`;
            dynamicInputArea.innerHTML = `
                        <canvas id="${params.variable_name}_canvas" width="300" height="150" style="border: 1px solid #000; background-color: #fff;"></canvas>
                        <input type="hidden" id="${params.variable_name}_image_data" value="">
                        <button onclick="
                            const canvas = document.getElementById('${params.variable_name}_canvas');
                            const imageData = canvas.toDataURL('image/png');
                            document.getElementById('${params.variable_name}_image_data').value = imageData;
                            handleUserInput('${params.variable_name}', 'drawing_board');
                        ">Submit Drawing</button>
                    `;
            const canvas = document.getElementById(`${params.variable_name}_canvas`);
            const ctx = canvas.getContext('2d');
            let isDrawing = false;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000';
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                ctx.beginPath();
                const rect = canvas.getBoundingClientRect();
                ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    const rect = canvas.getBoundingClientRect();
                    ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
                    ctx.stroke();
                }
            });
            canvas.addEventListener('mouseup', () => { isDrawing = false; });
            canvas.addEventListener('mouseout', () => { isDrawing = false; });
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); isDrawing = true; ctx.beginPath(); const rect = canvas.getBoundingClientRect(); ctx.moveTo(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top); });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (isDrawing) { const rect = canvas.getBoundingClientRect(); ctx.lineTo(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top); ctx.stroke(); } });
            canvas.addEventListener('touchend', () => { isDrawing = false; });
            canvas.addEventListener('touchcancel', () => { isDrawing = false; });
            break;
          default:
            chatContainer.innerHTML += `<div class="error-message">Unknown UI Command: ${action.command}</div>`;
        }
      }

      function handleUserInput(variableName, inputType) {
        let value;
        if (inputType === "text") {
          value = document.getElementById(variableName).value;
          if (!value.trim()) {
            alert("Please enter something.");
            return;
          }
        } else if (inputType === "radio") {
          const selectedRadio = document.querySelector(
            `input[name="${variableName}"]:checked`
          );
          if (!selectedRadio) {
            alert("Please select an option.");
            return;
          }
          value = selectedRadio.value;
        } else if (inputType === "checkbox") {
          const selectedCheckboxes = document.querySelectorAll(
            `input[name="${variableName}"]:checked`
          );
          if (selectedCheckboxes.length === 0) {
            alert("Please select at least one option.");
            return;
          }
          value = Array.from(selectedCheckboxes).map((cb) => cb.value);
        } else if (inputType === "slider") {
          value = document.getElementById(variableName).value;
        } else if (inputType === "rearrange_order") {
          const hiddenInput = document.getElementById(`${variableName}_ordered_values`);
          if (!hiddenInput || !hiddenInput.value || hiddenInput.value === '[]') {
            alert("Please arrange the items.");
            return;
          }
          try {
            value = JSON.parse(hiddenInput.value);
          } catch (e) {
            console.error("Error parsing rearranged order:", e);
            alert("Could not process rearrangement. Please try again.");
            return;
          }
        } else if (inputType === "drawing_board") {
          const hiddenInput = document.getElementById(`${variableName}_image_data`);
          if (!hiddenInput || !hiddenInput.value.trim()) {
            alert("Please draw something on the board.");
            return;
          }
          value = hiddenInput.value;
        }

        let nextCommand;
        let nextParams = {};

        // LLM will determine command based on `input_variable_name` and `input_type`
        // if no specific variable name matches.
        if (variableName === "topic_query") {
          nextCommand = "generate_course_plan";
          nextParams.query = value;
        } else if (
          variableName === "initial_paraphrase" ||
          variableName === "final_summary"
        ) {
          nextCommand = "evaluate_paraphrase"; 
          nextParams.user_input = value;
        } else if (variableName.startsWith("q_lesson") || variableName.startsWith("q_checkpoint_")) {
          // Both practice and checkpoint questions go to evaluate_answer
          nextCommand = "evaluate_answer";
          nextParams.user_answer = value;
          nextParams.question_id = variableName; // Crucial for LLM to know which question was answered
        } else if (variableName === "user_feedback_input") { // Handle specific feedback input
          nextCommand = "process_feedback"; // New command for feedback processing
          nextParams.feedback = value;
        }
        else {
          // Default fallback for any other unexpected UI input
          nextCommand = "handle_user_question";
          nextParams.user_question_value = value;
          nextParams.input_variable_name = variableName;
          nextParams.input_type = inputType;
        }

        sendActionToBackend(nextCommand, nextParams);
      }

      // On page load, send the initial 'init' command
      window.onload = () => {
        // Get user_name from a prompt or mock it
        const userName =
          prompt("Welcome! What's your name, learner?") || "Learner";
        sendActionToBackend("init", { user_name: userName });
        setupPersistentButtons(); // Setup persistent buttons on load
        updateProgressBar(currentStatus.current_lesson_progress); // Initialize progress bar
        updatePersistentButtons(); // Set initial state of persistent buttons
      };
    </script>
  </body>
</html>